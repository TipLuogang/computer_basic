6.6 linux的进程管理

6.7 作业管理之进程调度
进程调度
    计算机决策哪个就绪进程获取cpu使用权
    1.保存旧进程运行信息，请出旧进程
    2.选择新进程，准备运行环境分配cpu

    就绪队列的排队机制
        将就绪进程按一定的方式排列成队列，以便调度程序最快找到就绪进程
    选择运行进程的委派机制
        从就绪队列里面选出一个进程，将cpu资源分配给它
    新老进程的上下文切换机制
        保存当前进程的上下文信息，装入被委派执行进程的运行上下文
            cpu中有高速缓存cache， 将老进程的上下文备份放到主存， 再将新进程的上下文带调入cpu
    
    当老进程未执行完的时候：
        非抢占式的调度
            进程会一直占用cpu，不会被调度程序抢占正在被使用的cpu
            直到进程完成或IO阻塞才会让出cpu
        抢占式
            允许调度程序以一定策略暂停当前运行的进程，保存好旧进程的上下文信息，分配cpu给新进程

进程调度的算法
    先来先服务调度算法
        优先选择就绪队列前面的进程
    短进程优先调度算法
        优先选择就绪队列中估计运行时间最短的进程
        不利与长作业进程执行
    优先级调度算法
        进程附带优先权，调度程序优先选择权重高的进程
        使得紧迫任务可以优先处理
        （前台进程优先级高于后台进程，前台进程与用户交互）
    时间片轮转调度算法
        按先来先服务原则排列就绪队列
        每次从队列头部取出待执行进程，分配一个时间片执行
        不能保证及时响应用户
    多级反馈队列
        设置了多个队列，每个队列时间片大小都不同，例如 1,2,4,8,..。进程在第一个队列没执行完，就会被移到下一个队列
        每个队列优先权也不同，最上面的优先权最高。因此只有上一个队列没有进程在排队，才能调度当前队列上的进程。可以将这种调度算法看成是时间片轮转调度算法和优先级调度算法的结合。

6.8 作业管理之死锁
死锁
    两个或两个以上的进程在执行过程中，由于竞争资源或者彼此通信而造成的一种阻塞的现象，
    若无外力作用，它们都将无法推进下去。
    此时系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程
比如：哲学家就餐可能产生死锁

死锁的产生：
    竞争资源
        共享资源数量不满足各个进程需求
        各进程之间发生竞争导致死锁
        比如：进程1，2， 
        等待请求的资源被释放，自身占用的资源不释放          
    进程调度顺序不当
死锁的四个必要条件：
    互斥条件
        进程对资源的使用时排他的，某个资源只能由一个进程使用，其他进程需要使用只能等待资源的释放
    请求保持条件
        进程至少保持一个资源，又提出新的资源请求，新资源被占用，请求被阻塞，被阻塞进程不释放自己保持的资源
    不可剥夺条件
        进程获得的资源在未完成使用前不能被剥夺，获得的资源只能由进程自身释放
    环路等待条件  
        发生死锁时，必然存在进程-资源环形链
死锁的处理
    预防死锁的方法-破坏死锁四个必要条件中的一个或者多个
        请求保持条件
            系统规定进程运行之前，一次性申请所有需要的资源，进程在运行期间不会提出资源请求
        不可剥夺条件
            当一个进程请求的资源得不到满足的时候，必须释放占有的资源，进程运行时占有的资源可以被释放，意味着可以被剥夺
        环路等待条件
            可用资源线性排序，申请必须按照需要递增申请
    银行家算法
        可操作性的避免死锁的算法
        客户申请的贷款是有限的，每次申请需声明最大资金量，银行家在能够满足贷款时，都应该给用户贷款
        客户在使用完贷款后，能够及时归还贷款
    
        需要三个数据结构
            已分配资源表
            所需资源表
            可分配资源表

6.9 存储管理之内存分配与回收
    早期计算机不需要过多的存储管理，随着计算机和程序越来越复杂，存储管理成为必要
    解决三个问题：
        确保计算机有足够的内存处理数据
        确保程序可以从可用内存中获取一部分内存使用
        确保程序可以归还使用后的内存以供其他程序使用

    内存分配的过程
        单一连续分配，只能在单用户，单进程的os中使用
        固定分区分配，支持多道程序最简单的存储分配方式
            内存空间被划分为若干固定大小的区域
            每个分区只能提供给一个程序使用，互不干扰
        动态分区分配，根据进程实际需要，动态分配内存空间
            涉及相关数据结构，分配算法
            数据结构：
                动态分区空闲表
                动态分区空闲链
            动态分区分配算法
                首次适应算法（FF算法）
                    分配内存时，从开始顺序查找适合内存区（空闲链）
                    若没有合适的空闲区，则该次分配失败
                    每次都从头部开始，使得头部地址空间不断被划分
                最佳适应算法（BF算法）
                    要求空闲链按照容量大小排序
                    每一次需要分配的时候，遍历空闲链找到最佳合适空闲区
                快速适应算法（QF算法）
                    要求多个空闲链，每个链表存储一种容量的空闲区
    内存回收的过程
        空闲链表

6.10 存储管理之段页式存储管理
    从进程的角度去理解存储管理，os式如何管理进程的内存空间
    页式存储管理
        页面(page)：相对逻辑空间的定义
            字块：相对物理设备的定义
        将进程逻辑空间等分为若干大小的页面
        相应的把物理内存空间分成与页面大小一样的物理块
        以页面为单位把进程空间装进物理内存中分散的物理块

        内存碎片：页面分配给空闲链表中的节点2-3， 导致部分内存不能被页面使用，造成内存碎片
        因此，页面大小应该适中，过大（难以分配），过小（内存碎片过多），通常大小为：512B~8KB
        
        将进程逻辑空间的每一个页面都放在内存的物理块中，进程的某一个页面对应哪一个字块呢？
        页表（page table）：记录进程逻辑空间与物理空间的映射的表
            页面1                           页面1  (1)
            页面2                       
            页面3                           页面2   (3)
            页面4                           
            页面5                           页面3 ...(5)
            进程逻辑空间                     主存
        
            页表：
            页面    字块
            1       1
            2       3
            3       5

            
        页地址：页号 + 页内偏移
            32位逻辑地址空间的分页系统：32位系统进程的寻址空间为4G， 页面大小为4KB
            每个进程页表中的页表项可达：4G/4KB=2的20次方=1M个
            如果每个页表项占用1Byte，则每个进程仅仅页表就要占用1MB内存空间

            多级页表
                根页表  二级页表
                按需取二级页表，节省内存空间

            如果有一段连续的逻辑分布在多个页面，将大大降低执行效率

    段式存储管理
        将进程的逻辑空间划分为若干段（非等分）
        段的长度由连续逻辑的长度决定
        主函数main，子程序段x，子函数y等
        需要一个表来保存逻辑空间到物理空间的映射：段表（多了段长字段）
            段表
            段号    基址    段长

        段地址：段号 + 段内偏移

        段式管理和页式管理都离散地管理了进程的逻辑空间
        页是物理单位，段式逻辑单位
        分页式为了合理利用空间，分段式为了满足用户需求
        页大小由硬件固定，段长度可动态变化
        页表信息式一维的，段表信息式二维的
    段页式存储管理
        分页可以有效提高内存的利用率 （虽然说存在内存碎片）
        分段可以更好的满足用户需求
        两者结合，形成段页式存储管理

        先将逻辑空间按段式管理分成若干段
        再把端内空间按页式管理等分为若干页

        段页地址：段号 + 段内页号 + 页内地址

6.11 存储管理之虚拟内存
    一个游戏有十几G，内存只有4G，游戏是怎么运行起来的
    虚拟内存概述
        有些进程实际需要的内存很大，超过物理内存容量
        多道程序设计，使得每个进程可用物理内存更加稀缺
        不可能无限增加物理内存
        虚拟内存时os内存管理的关键技术
        使得多道程序和大程序的运行成为现实
        把程序使用内存划分，将部分暂时不使用的内存放置在辅存

    程序的局部性原理
        cpu访问存储器的时候，无论是存取指令还是存取数据，所访问的存储单元都趋于聚集在一个较小的连续区域中
        程序运行时，无需全部装入内存，装载部分即可
        如果访问页不在内存，则发出缺页中断，发起页面置换
        从用户层面看，程序拥有很大的空间，即是虚拟内存

    虚拟内存的置换算法解决容量问题（计组-内存和cache的页面置换就使用了相关的算法，解决速度问题）
        先进先出（FIFO）
        最不经常使用（LFU）- 需额外的空间记录字块的使用呢频率
        最近最少使用（LRU）- 一般使用双向链表实现

6.12 Linux的存储管理
    Buddy内存管理算法
        经典的内存管理算法，Linux 实际运行的一种内存管理算法
        基于计算机在处理二进制的优势：具有极高的效率 
        算法主要是为了解决 内存外碎片 的问题，努力让内存分配与相邻内存合并能快速进行

        页内碎片
            已经被分配出去的内存空间大于进程请求所需要的内存空间，不能被利用的内存空间就是内部碎片
        页外碎片
            还没有被分配出去，但是由于大小而无法分配给申请内存空间的新进程的内存空闲块
        
        内存分配原则
            每一块内存都是向上取整为2的幂大小
                70K -> 128K， 129K -> 256K, 666K -> 1024K
       
        伙伴系统：伙伴 指的是 一片内存的伙伴，一片连续内存的伙伴是相邻的另一片大小一样的连续内存

        创建一系列空闲块链表，每一个链表都是2的幂大小（1k链表大小，2k链表大小，4k链表大小 ...1M链表大小）
        假设存储空间有1M大小，则初始化空闲块链表如下：
            1k  null
            2k  null
            4k  null
            ...
            1M  1M
        假设需要分配100k内存
            100k向上取整 -> 128k
            查询空闲块链表里面是否有128k空闲内存块
            没有，查询是否有256k的空闲内存块
            没有，查询是否有512k的空闲内存块
            没有，查询是否有1M的空闲内存块
            有，摘下1M的空闲内存块，分配出去
                则：1M  1M  -->  1M   null
            从1M里面拆下512k放在512k的空闲链表，其余的分配出去
                则：512k  null  --> 512k  512k 
                判断512k是否满足了最小的需求，发现没有满足
            拆下256k放在256k的空闲链表，其余的分配出去
                256k  null --> 256k   256K
                剩下的256k：判断是否满足了100k的最小要求，发现没有满足最小的要求
            拆下128k放在128k的空闲链表，其余的分配出去
                128k  null --> 128k   128K
                剩下的128k：发现满足了100k的最小要求
            分配完毕
        
        回收内存的过程
            判断刚才分配的内存伙伴在空闲链表上吗
            在，移除伙伴，合并为256k空闲内存，判断 （可以快速合并回收区和空闲区）
            在，移除伙伴，合并为512k空闲内存，判断
            在，移除伙伴，合并为1k空闲内存，判断
            不在，插入1M空闲链表，回收完成
        将内存外碎片问题，转移成内存内碎片问题，但还是大大提升了内存的利用效率，因为通常来说，内存外碎片要比内存内碎片要大


    Linux交换空间   
        交换空间（swap）是磁盘的一个分区
        当Linux物理内存满时，会把一些内存交换至swap空间，使得linux物理量内存有更多的空间去运行
        swap空间是系统初始化的时候系统配置的

        实际系统的交换空间：
            linux： top 可以看到swap交换空间：总swap大小，还没有使用的swap大小，已经使用的swap大小

        不推荐使用swap    
            swap存储的地方在磁盘，磁盘速度慢，频繁使用swap的话，会使得Linux系统运行起来非常慢
        
        用处：
        冷启动内存依赖：对于一些大型的应用程序，启动的时候需要使用大量的内存，这些内存很多时候只是在启动的时候用了，
            后续运行的时候很少很少使用这部分内存，可以将这些不怎么使用的内存数据保存在swap空间，释放更多的物理内存
        
        系统睡眠依赖：当linux系统需要睡眠的时候，会把系统里面所有的内存数据保存到swap空间，等下次系统需要启动的时候，
            才把这些数据从swap空间加载到内存，加快系统的启动速度
        
        大进程空间依赖：有些进程确实需要使用很多的内存空间，物理内存不够使用，需要把进程需要使用到的内存暂时保存到swap
            空间，使得整个大的进程也能运行起来
        
        概念与虚拟内存很类似
            swap空间存在于磁盘              虚拟内存存在于磁盘
            swap空间与主存发生置换           虚拟内存与主存发生置换
            swap空间是操作系统的概念         虚拟内存是进程概念
            swap空间解决系统物理内存不足问题   虚拟内存解决进程物理内存不足问题   








