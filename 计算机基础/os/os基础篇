6.6 linux的进程管理

6.7 作业管理之进程调度
进程调度
    计算机决策哪个就绪进程获取cpu使用权
    1.保存旧进程运行信息，请出旧进程
    2.选择新进程，准备运行环境分配cpu

    就绪队列的排队机制
        将就绪进程按一定的方式排列成队列，以便调度程序最快找到就绪进程
    选择运行进程的委派机制
        从就绪队列里面选出一个进程，将cpu资源分配给它
    新老进程的上下文切换机制
        保存当前进程的上下文信息，装入被委派执行进程的运行上下文
            cpu中有高速缓存cache， 将老进程的上下文备份放到主存， 再将新进程的上下文带调入cpu
    
    当老进程未执行完的时候：
        非抢占式的调度
            进程会一直占用cpu，不会被调度程序抢占正在被使用的cpu
            直到进程完成或IO阻塞才会让出cpu
        抢占式
            允许调度程序以一定策略暂停当前运行的进程，保存好旧进程的上下文信息，分配cpu给新进程

进程调度的算法
    先来先服务调度算法
        优先选择就绪队列前面的进程
    短进程优先调度算法
        优先选择就绪队列中估计运行时间最短的进程
        不利与长作业进程执行
    优先级调度算法
        进程附带优先权，调度程序优先选择权重高的进程
        使得紧迫任务可以优先处理
        （前台进程优先级高于后台进程，前台进程与用户交互）
    时间片轮转调度算法
        按先来先服务原则排列就绪队列
        每次从队列头部取出待执行进程，分配一个时间片执行
        不能保证及时响应用户
    多级反馈队列
        设置了多个队列，每个队列时间片大小都不同，例如 1,2,4,8,..。进程在第一个队列没执行完，就会被移到下一个队列
        每个队列优先权也不同，最上面的优先权最高。因此只有上一个队列没有进程在排队，才能调度当前队列上的进程。可以将这种调度算法看成是时间片轮转调度算法和优先级调度算法的结合。

6.8 作业管理之死锁
死锁
    两个或两个以上的进程在执行过程中，由于竞争资源或者彼此通信而造成的一种阻塞的现象，
    若无外力作用，它们都将无法推进下去。
    此时系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程
比如：哲学家就餐可能产生死锁

死锁的产生：
    竞争资源
        共享资源数量不满足各个进程需求
        各进程之间发生竞争导致死锁
        比如：进程1，2， 
        等待请求的资源被释放，自身占用的资源不释放          
    进程调度顺序不当
死锁的四个必要条件：
    互斥条件
        进程对资源的使用时排他的，某个资源只能由一个进程使用，其他进程需要使用只能等待资源的释放
    请求保持条件
        进程至少保持一个资源，又提出新的资源请求，新资源被占用，请求被阻塞，被阻塞进程不释放自己保持的资源
    不可剥夺条件
        进程获得的资源在未完成使用前不能被剥夺，获得的资源只能由进程自身释放
    环路等待条件  
        发生死锁时，必然存在进程-资源环形链
死锁的处理
    预防死锁的方法-破坏死锁四个必要条件中的一个或者多个
        请求保持条件
            系统规定进程运行之前，一次性申请所有需要的资源，进程在运行期间不会提出资源请求
        不可剥夺条件
            当一个进程请求的资源得不到满足的时候，必须释放占有的资源，进程运行时占有的资源可以被释放，意味着可以被剥夺
        环路等待条件
            可用资源线性排序，申请必须按照需要递增申请
    银行家算法
        可操作性的避免死锁的算法
        客户申请的贷款是有限的，每次申请需声明最大资金量，银行家在能够满足贷款时，都应该给用户贷款
        客户在使用完贷款后，能够及时归还贷款
    
        需要三个数据结构
            已分配资源表
            所需资源表
            可分配资源表

6.9 存储管理之内存分配与回收
    早期计算机不需要过多的存储管理，随着计算机和程序越来越复杂，存储管理成为必要
    解决三个问题：
        确保计算机有足够的内存处理数据
        确保程序可以从可用内存中获取一部分内存使用
        确保程序可以归还使用后的内存以供其他程序使用

    内存分配的过程
        单一连续分配，只能在单用户，单进程的os中使用
        固定分区分配，支持多道程序最简单的存储分配方式
            内存空间被划分为若干固定大小的区域
            每个分区只能提供给一个程序使用，互不干扰
        动态分区分配，根据进程实际需要，动态分配内存空间
            涉及相关数据结构，分配算法
            数据结构：
                动态分区空闲表
                动态分区空闲链
            动态分区分配算法
                首次适应算法（FF算法）
                    分配内存时，从开始顺序查找适合内存区（空闲链）
                    若没有合适的空闲区，则该次分配失败
                    每次都从头部开始，使得头部地址空间不断被划分
                最佳适应算法（BF算法）
                    要求空闲链按照容量大小排序
                    每一次需要分配的时候，遍历空闲链找到最佳合适空闲区
                快速适应算法（QF算法）
                    要求多个空闲链，每个链表存储一种容量的空闲区
    内存回收的过程
        空闲链表
        









