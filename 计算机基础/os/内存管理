1. 内存的基础知识
    程序执行前需要先放到内存中才能被CPU处理——缓和CPU与硬盘之间的速度矛盾
    在多道程序环境下，系统中会有多个程序并发执行，也就是说会有多个程序的数据需要同时放到内存中。
        那么，如何区分各个程序的数据是放在什么地方的呢? 方案:给内存的存储单元编地址
    内存地址从0开始，每个地址对应一个存储单元，如果计算机按字节编址，则每个存储单元大小为1B(8个二进制位)
    一台手机/电脑 有 4GB 内存则：可以存放4*2的30次方个字节。如果是按字节编址的话，也就是有4*2的30次方=2的32次方个“小房间”

    程序经过编译、链接后生成的指令中指明的是逻辑地址(相对地址)，即:相对于进程的起始地址而言的地址
    如何将指令中的逻辑地址转换为物理地址?
    装入的三种方式：
        绝对装入:在编译时，如果知道程序将放到内存中的哪个位置，编译程序将产生绝对地址的目标代码。
            装入程序按照装入模块中的地址，将程序和数据装入内存，只适用于单道程序环境。
        可重定位装入：编译、链接后的装入模块的地址都是从0开始的，指令中使用的地址、数据存放的地址都是相对于起始地址而言的逻辑地址。
            可根据内存的当前情况，将装入模块装入到内存的适当位置。装入时对地址进行“重定位”，将逻辑地址变换为物理地址(地址变换是在装入时一次完成的)。
            特点：在一个作业装入内存时，必须分配其要求的全部内存空间，如果没有足够的内存，就不能装入该作业。 作业一旦进入内存后，在运行期间就不能再移动，也不能再申请内存空间。
        动态重定位：编译、链接后的装入模块的地址都是从0开始的。装入程序把装入模块装入内存后，并不会立即把逻辑地址转换为物理地址，而是把地址转换推迟到程序真正要执行时才进行。
            因此装入内存后所有的地址依然是逻辑地址。这种方式需要一个重定位寄存器的支持。
            允许程序在内存中发生移动。并且可将程序分配到不连续的存储区中；在程序运行前只需装入它的部分代码即可投入运行，然后在程序运行期间，
            根据需要动态申请分配内存；便于程序段的共享，可以向用户提供一个比存储空间大得多的地址空间。

2. 内存管理的概念
    内存空间的分配与回收
        装入进程时很多位置都可以放，那应该放在哪里
        操作系统要怎么记录哪些内存区域已经被分配出去了，哪些又还空闲?
        当进程运行结束之后，如何将进程占用的内存空间回收?
    内存空间的扩充
        操作系统需要提供某种技术从逻辑上对内存空间进行扩充
    地址转换
        操作系统需要提供地址转换功能，负责程序的逻辑地址与物理地址的转换
    存储保护
        操作系统需要提供内存保护功能。保证各进程在各自存储空间内 运行，互不干扰
        采用重定位寄存器(又称基址寄存器)和界地址寄存器(又称限长寄存器)进行越界检查

3. 内存空间的扩充
    覆盖技术：将程序分为多个段(多个模块)。常用的段常驻内存，不常用的段在需要时调入内存，必须由程序员声明覆盖结构，增加了用户编程负担
    交换技术：内存空间紧张时，系统将内存中某些进程暂时换出外存，把外存中某些已具备运行条件的进程换入内存(进程在内存与磁盘间动态调度)
        中级调度(内存调度)，就是要决定将哪个处于挂起状态的进程重新调入内存。
        暂时换出外存等待的进程状态为挂起状态(挂起态，suspend) 挂起态又可以进一步细分为就绪挂起、阻塞挂起两种状态
        由于交换时需要花费大量的CPU时间，这将影响对用户的响应时间，因此，减少交换的信息量是交换技术的关键问题。
        合理的做法：在外存中保留每个程序的交换副本，换出时仅将执行时修改过的部分复制到外存。
    覆盖技术和交换技术的发展导致了虚拟存储技术的出现
    虚拟存储技术：
        传统存储管理方式（连续分配&非连续分配）的特征、缺点：
            一次性:作业必须一次性全部装入内存后才能开始运行
            驻留性:一旦作业被装入内存，就会一直驻留在内存中，直至作业运行结束。
        局部性原理：时间局部性，空间局部性
        基于局部性原理，
            在程序装入时，可以将程序中很快会用到的部分装入内存，暂时用不到的部分留在外存
            在程序执行过程中，当所访问的信息不在内存时，由操作系统负责将所需信息从外存调入内存，然后继续执行程序。
            若内存空间不够，由操作系统负责将内存中暂时用不到的信息换出到外存。
        在操作系统的管理下，在用户看来似乎有一个比实际内存大得多的内存，这就是虚拟内存
        虚拟内存的最大容量是由计算机的地址结构(CPU寻址范围)确定的
        虚拟内存的实际容量 = min(内存和外存容量之和，CPU寻址范围)
        虚拟内存的实现需要建立在离散分配的内存管理方式基础上
            请求分页、分段存储管理：操作系统要提供请求调页(或请求调段)、页面置换(或段置换)功能


4. 内存空间的分配与回收
    连续分配管理方式
        单一连续分配
            内存被分为系统区和用户区。系统区通常位于内存的低地址部分，用于存放操作系统相关数据；
            用户区用于存放用户进程相关数据。内存中只能有一道用户程序，用户程序独占整个用户区空间。
        固定分区分配
            整个用户空间划分为若干个固定大小的分区，在每个分区中只装入一道作业，
            这样就形成了最早的、最简单的一种可运行多道程序的内存管理方式。
        动态分区分配
            不会预先划分内存分区，而是在进程装入内存时，根据进程的大小动态地建立分区，并使分区的大小正好适合进程的需要。
            因此系统分区的大小和数 目是可变的。
            (eg:假设某计算机内存大小为 64MB，系统区 8MB，用户区共56 MB...)
            记录内存使用情况两种常用的数据结构
                空闲分区表:每个空闲分区对应一个表项。表项中包含分区号、分区大小、分区起始地址等信息
                空闲分区链:每个分区的起始部分和末尾部分分别设置前向指针和后向指针。起始部分处还可记录分区大小等信息
            当很多个空闲分区都能满足需求时，应该选择哪个分区进行分配?比如：有20M,10M,4M空闲分区，有新进程(5M)应分配到哪个分区？
                把一个新作业装入内存时，须按照一定的动态分区分配算法，从空闲分区表(或空闲分区链)中选出一个分区分配给该作业。
                由于分配算法算法(动态分区分配算法)对系统性能有很大的影响，因此人们对它进行了广泛的研究。
            动态分区分配没有内部碎片，但是有外部碎片。可以通过紧凑(拼凑，Compaction)技术来解决外部碎片
    非连续分配管理方式
        基本分页存储管理(6)、基本分段存储管理、段页式存储管理

5. 动态分区分配算法
    在动态分区分配方式中，当很多个空闲分区都能满足需求时，应该选择哪个分区进行分配?
    首次适应算法：每次都从低地址开始查找，找到第一个能满足大小的空闲分区。（空闲分区以地址递增的次序排列）
    最佳适应算法：由于动态分区分配是一种连续分配方式，为各进程分配的空间必须是连续的一整片区域。
        因此为了保证当“大进程”到来时能有连续的大片空间，可以尽可能多地留下大片的空闲区，
        即，优先使用更小的空闲区（空闲分区按容量递增次序链接），产生很多的外部碎片
    最坏适应算法：为了解决最佳适应算法的问题——即留下太多难以利用的小碎片，可以在每次分配时优先使用最大的连续空闲区，这样分配后剩余的空闲区就不会太小，更方便使用。
        导致较大的连续空闲区被 迅速用完。如果之后有“大进程”到达，就没有内存分区可用了。
    邻近适应算法：首次适应算法每次都从链头开始查找的。这可能会导致低地址部分出现很多小的空闲分区，而每次分配查找时，都要经过这些分区，
        因此也增加了查找的开销。如果每次都从上次查找结束的位置开始检索，就能解决上述问题。
        空闲分区以地址递增的顺序排列(可排成一个循环链表)
        无论低地址、高地址部分的空闲分区都有相同的概率被使用，也就导致了高地址部分的大分区更可能被使用，划分为小分区，最后导致无大分区可用
    综合来看，四种算法中，首次适应算法的效果反而更好

6. 基本分页存储管理的基本概念
    非连续分配:为用户进程分配的可以是一些分散的内存空间。
    进程的逻辑地址空间，逻辑地址(相对地址)          进程的物理地址空间，物理地址(绝对地址)

    分页存储：
        将内存空间分为一个个大小相等的分区(比如:每个分区 4KB)，每个分区就是一个“页框”(页框=页帧=内存块=物理块=物理页面)。
        每个页框有一个编号，即“页框号”(页框号=页帧号=内存块号=物理块号=物理页号)，页框号从0开始。

        将进程的逻辑地址空间也分为与页框大小相等的一个个部分， 每个部分称为一个“页”或“页面” 。
        每个页面也有一个编号， 即“页号”，页号也是从0开始。

        操作系统以页框为单位为各个进程分配内存空间。进程的每个页面分别放入一个页框中。也就是说，进程的页面与内存的页框有一一对应的关系。
        各个页面不必连续存放，可以放到不相邻的各个页框中
        (注:进程的最后一个页面可能没有一个页框那么大。也就是说，分页存储有可能产生内部碎片，因此页框不能太大，否则可能产生过大的内部碎片造成浪费)

        为了能知道进程的每个页面在内存中存放的位置，操作系统要为每个进程建立一张页表。注:页表通常存在PCB(进程控制块)中
        1. 一个进程对应一张页表
        2. 进程的每个页面对应一个页表项
        3. 每个页表项由“页号”和“块号”组成
        4. 页表记录进程页面和实际存放的内存块之间的映射关系 
        5. 每个页表项的长度是相同的
        假设某系统物理内存大小为 4GB，页面大小为 4KB，则 每个页表项至少应该为多少字节?
            内存块大小=页面大小=4KB= 2的12次方B
            4GB的内存总共会被分为 2的32次方 / 2的12次方 = 2的20次方 个内存块内存
            内存块号的范围应该是 0 ~ 2的20次方 -1 
            内存块号至少要用 20 bit 来表示 
            至少要用3B来表示块号(3*8=24bit)
                计算机中内存块的数量-->页表项中块号至少占多少字节
            页表项连续存放，因此页号可以是隐含的，不占存储空间(类比数组)
            由于页号是隐含的，因此每个页表项占3B，存储整个页表至少需要 3*(n+1)B
        
        如何实现地址的转换:
            逻辑地址 可以拆分为(页号，页内偏移量) 通过页号查询页表，可知页面在内存中的起始地址
            页面在内存中的起始地址+页内偏移量 = 实际的物理地址

7. 页面置换算法
    用页面置换算法决定应该换出哪个页面
    页面的换入、换出需要磁盘 I/O，会有较大的开销，因此好的页面置换算法应该追求更少的缺页率
    最佳置换算法(OPT，Optimal):每次选择淘汰的页面将是以后永不使用，或者在最长时间内不再被访问的页面，
        这样可以保证最低的缺页率。无法实现
    先进先出置换算法(FIFO): 每次选择淘汰的页面是最早进入内存的页面
        Belady 异常——当为进程分配的物理块数增大时，缺页次数不减反增的异常现象
        只有FIFO 算法会产生Belady异常，先进入的页面也有可能最经常被访问，算法性能差
    最近最久未使用置换算法(LRU，least recently used):每次淘汰的页面是最近最久未使用的页面 
        实现方法:赋予每个页面对应的页表项中，用访问字段记录该页面自上次被访问以来所经历的时间t。 
            当需要淘汰一个页面时，选择现有页面中 t 值最大的，即最近最久未使用的页面。
            该算法的实现需要专门的硬件支持，虽然算法性能好，但是实现困难，开销大
    时钟置换算法：是一种性能和开销较均衡的算法，又称CLOCK算法，或最近未用算法(NRU，Not Recently Used)
        为每个页面设置一个访问位，再将内存中的页面都通过链接指针链接成 一个循环队列。当某页被访问时，其访问位置为1。
        当需要淘汰一个页面时，只需检查页的访问位。 如果是0，就选择该页换出；如果是1，则将它置为0，暂不换出，继续检查下一个页面，
        若第一轮扫 描中所有页面都是1，则将这些页面的访问位依次置为0后，
        再进行第二轮扫描(第二轮扫描中一定会有访问位为0的页面，因此简单的CLOCK算法选择一个淘汰页面最多会经过两轮扫描)
    改进型的时钟置换算法：只有被淘汰的页面被修改过时，才需要写回外存。除了考虑一个页面最近有没有被访问过之外，操作系统还应考虑页面有没有被修改过。
        在其他条件都相同时，应优先淘汰没有修改过的页面，避免I/O操作

8. 页面分配策略
    驻留集:指请求分页存储管理中给进程分配的物理块的集合，在采用了虚拟存储技术的系统中，驻留集大小一般小于进程的总大小
    固定分配:操作系统为每个进程分配一组固定数目的物理块，在进程运行期间不再改变。即，驻留集大小不变
    可变分配:先为每个进程分配一定数目的物理块，在进程运行期间，可根据情况做适当的增加或减少。即，驻留集大小可变
    局部置换:发生缺页时只能选进程自己的物理块进行置换。
    全局置换:可以将操作系统保留的空闲物理块分配给缺页进程，也可以将别的进程持有的物理块置换到外存，再分配给缺页进程。

    何时调入页面：
        预调页策略:根据局部性原理，一次调入若干个相邻的页面可能比一次调入一个页面更高效。但如果提前调入的页面中大多数都没被访问过，
            则又是低效的。因此可以预测不久之后可能访问到的页面，将它们预先调入内存，
            但目前预测成功率只有50%左右。故这种策略主要用于进程的首次调入， 由程序员指出应该先调入哪些部分
        请求调页策略:进程在运行期间发现缺页时才将所缺页面调入内存。由这种策略调入的页面一定会被访问到，
            但由于每次只能调入一页，而每次调页都要磁盘I/O操作，因此I/O开销较大。
    从何处调页：
        系统拥有足够的对换区空间:页面的调入、调出都是在内存与对换区之间进行，这样可以保证页面的调入、调出速度很快。
            在进程运行前，需将进程相关的数据从文件区复制到对换区。
        系统缺少足够的对换区空间:凡是不会被修改的数据都直接从文件区调入，由于这些页面不会被修改，因此换出时不必写回磁盘，
            下次需要时再从文件区调入即可。对于可能被修改的部分，换出时需写回磁盘对换区，下次需要时再从对换区调入。
        UNIX方式:运行之前进程有关的数据全部放在文件区，故未使用过的页面，都可从文件区调入。
            若被使用过的页面需要换出，则写回对换区，下次需要时从对换区调入。

    抖动(颠簸)现象: 刚刚换出的页面马上又要换入内存，刚刚换入的页面马上又要换出外存，这种频繁的页面调度行为称
        为抖动，或颠簸。产生抖动的主要原因是进程频繁访问的页面数目高于可用的物理块数(分配给进程的物理块不够)
    工作集:指在某段时间间隔里，进程实际访问页面的集合。
        操作系统会根据“窗口尺寸”来算出工作集
        工作集大小可能小于窗口尺寸，实际应用中，操作系统可以统计进程的工作集大小，根据工作集大小给进程分配若干内存块。
            如:窗口尺寸为5，经过一段时间的监测发现某进程的工作集最大为3，那么说明该进程有很好的局部性，可以给这个进程分配3个以上的内存块即可满足进程的运行需要。 
            一般来说，驻留集大小不能小于工作集大小，否则进程运行过程中将频繁缺页







