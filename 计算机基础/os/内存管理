1. 内存的基础知识
    程序执行前需要先放到内存中才能被CPU处理——缓和CPU与硬盘之间的速度矛盾
    在多道程序环境下，系统中会有多个程序并发执行，也就是说会有多个程序的数据需要同时放到内存中。
        那么，如何区分各个程序的数据是放在什么地方的呢? 方案:给内存的存储单元编地址
    内存地址从0开始，每个地址对应一个存储单元，如果计算机按字节编址，则每个存储单元大小为1B(8个二进制位)
    一台手机/电脑 有 4GB 内存则：可以存放4*2的30次方个字节。如果是按字节编址的话，也就是有4*2的30次方=2的32次方个“小房间”

    程序经过编译、链接后生成的指令中指明的是逻辑地址(相对地址)，即:相对于进程的起始地址而言的地址
    如何将指令中的逻辑地址转换为物理地址?
    装入的三种方式：
        绝对装入:在编译时，如果知道程序将放到内存中的哪个位置，编译程序将产生绝对地址的目标代码。
            装入程序按照装入模块中的地址，将程序和数据装入内存，只适用于单道程序环境。
        可重定位装入：编译、链接后的装入模块的地址都是从0开始的，指令中使用的地址、数据存放的地址都是相对于起始地址而言的逻辑地址。
            可根据内存的当前情况，将装入模块装入到内存的适当位置。装入时对地址进行“重定位”，将逻辑地址变换为物理地址(地址变换是在装入时一次完成的)。
            特点：在一个作业装入内存时，必须分配其要求的全部内存空间，如果没有足够的内存，就不能装入该作业。 作业一旦进入内存后，在运行期间就不能再移动，也不能再申请内存空间。
        动态重定位：编译、链接后的装入模块的地址都是从0开始的。装入程序把装入模块装入内存后，并不会立即把逻辑地址转换为物理地址，而是把地址转换推迟到程序真正要执行时才进行。
            因此装入内存后所有的地址依然是逻辑地址。这种方式需要一个重定位寄存器的支持。
            允许程序在内存中发生移动。并且可将程序分配到不连续的存储区中；在程序运行前只需装入它的部分代码即可投入运行，然后在程序运行期间，
            根据需要动态申请分配内存；便于程序段的共享，可以向用户提供一个比存储空间大得多的地址空间。

2. 内存管理的概念
    内存空间的分配与回收
        装入进程时很多位置都可以放，那应该放在哪里
        操作系统要怎么记录哪些内存区域已经被分配出去了，哪些又还空闲?
        当进程运行结束之后，如何将进程占用的内存空间回收?
    内存空间的扩充
        操作系统需要提供某种技术从逻辑上对内存空间进行扩充
    地址转换
        操作系统需要提供地址转换功能，负责程序的逻辑地址与物理地址的转换
    存储保护
        操作系统需要提供内存保护功能。保证各进程在各自存储空间内 运行，互不干扰
        采用重定位寄存器(又称基址寄存器)和界地址寄存器(又称限长寄存器)进行越界检查

3. 内存空间的扩充
    覆盖技术：将程序分为多个段(多个模块)。常用的段常驻内存，不常用的段在需要时调入内存，必须由程序员声明覆盖结构，增加了用户编程负担
    交换技术：内存空间紧张时，系统将内存中某些进程暂时换出外存，把外存中某些已具备运行条件的进程换入内存(进程在内存与磁盘间动态调度)
        中级调度(内存调度)，就是要决定将哪个处于挂起状态的进程重新调入内存。
        暂时换出外存等待的进程状态为挂起状态(挂起态，suspend) 挂起态又可以进一步细分为就绪挂起、阻塞挂起两种状态
        由于交换时需要花费大量的CPU时间，这将影响对用户的响应时间，因此，减少交换的信息量是交换技术的关键问题。
        合理的做法：在外存中保留每个程序的交换副本，换出时仅将执行时修改过的部分复制到外存。
    覆盖技术和交换技术的发展导致了虚拟存储技术的出现

4. 内存空间的分配与回收
    连续分配管理方式
        单一连续分配
            内存被分为系统区和用户区。系统区通常位于内存的低地址部分，用于存放操作系统相关数据；
            用户区用于存放用户进程相关数据。内存中只能有一道用户程序，用户程序独占整个用户区空间。
        固定分区分配
            整个用户空间划分为若干个固定大小的分区，在每个分区中只装入一道作业，
            这样就形成了最早的、最简单的一种可运行多道程序的内存管理方式。
        动态分区分配
            不会预先划分内存分区，而是在进程装入内存时，根据进程的大小动态地建立分区，并使分区的大小正好适合进程的需要。
            因此系统分区的大小和数 目是可变的。
            (eg:假设某计算机内存大小为 64MB，系统区 8MB，用户区共56 MB...)
            记录内存使用情况两种常用的数据结构
                空闲分区表:每个空闲分区对应一个表项。表项中包含分区号、分区大小、分区起始地址等信息
                空闲分区链:每个分区的起始部分和末尾部分分别设置前向指针和后向指针。起始部分处还可记录分区大小等信息
            当很多个空闲分区都能满足需求时，应该选择哪个分区进行分配?比如：有20M,10M,4M空闲分区，有新进程(5M)应分配到哪个分区？
                把一个新作业装入内存时，须按照一定的动态分区分配算法，从空闲分区表(或空闲分区链)中选出一个分区分配给该作业。
                由于分配算法算法(动态分区分配算法)对系统性能有很大的影响，因此人们对它进行了广泛的研究。
            动态分区分配没有内部碎片，但是有外部碎片。可以通过紧凑(拼凑，Compaction)技术来解决外部碎片
    非连续分配管理方式
        基本分页存储管理(6)、基本分段存储管理、段页式存储管理

5. 动态分区分配算法
    在动态分区分配方式中，当很多个空闲分区都能满足需求时，应该选择哪个分区进行分配?
    首次适应算法：每次都从低地址开始查找，找到第一个能满足大小的空闲分区。（空闲分区以地址递增的次序排列）
    最佳适应算法：由于动态分区分配是一种连续分配方式，为各进程分配的空间必须是连续的一整片区域。
        因此为了保证当“大进程”到来时能有连续的大片空间，可以尽可能多地留下大片的空闲区，
        即，优先使用更小的空闲区（空闲分区按容量递增次序链接），产生很多的外部碎片
    最坏适应算法：为了解决最佳适应算法的问题——即留下太多难以利用的小碎片，可以在每次分配时优先使用最大的连续空闲区，这样分配后剩余的空闲区就不会太小，更方便使用。
        导致较大的连续空闲区被 迅速用完。如果之后有“大进程”到达，就没有内存分区可用了。
    邻近适应算法：首次适应算法每次都从链头开始查找的。这可能会导致低地址部分出现很多小的空闲分区，而每次分配查找时，都要经过这些分区，
        因此也增加了查找的开销。如果每次都从上次查找结束的位置开始检索，就能解决上述问题。
        空闲分区以地址递增的顺序排列(可排成一个循环链表)
        无论低地址、高地址部分的空闲分区都有相同的概率被使用，也就导致了高地址部分的大分区更可能被使用，划分为小分区，最后导致无大分区可用
    综合来看，四种算法中，首次适应算法的效果反而更好

6. 基本分页存储管理的基本概念
    非连续分配:为用户进程分配的可以是一些分散的内存空间。
    进程的逻辑地址空间，逻辑地址(相对地址)          进程的物理地址空间，物理地址(绝对地址)

    分页存储：
        将内存空间分为一个个大小相等的分区(比如:每个分区 4KB)，每个分区就是一个“页框”(页框=页帧=内存块=物理块=物理页面)。
        每个页框有一个编号，即“页框号”(页框号=页帧号=内存块号=物理块号=物理页号)，页框号从0开始。

        将进程的逻辑地址空间也分为与页框大小相等的一个个部分， 每个部分称为一个“页”或“页面” 。
        每个页面也有一个编号， 即“页号”，页号也是从0开始。

        操作系统以页框为单位为各个进程分配内存空间。进程的每个页面分别放入一个页框中。也就是说，进程的页面与内存的页框有一一对应的关系。
        各个页面不必连续存放，可以放到不相邻的各个页框中
        (注:进程的最后一个页面可能没有一个页框那么大。也就是说，分页存储有可能产生内部碎片，因此页框不能太大，否则可能产生过大的内部碎片造成浪费)

        为了能知道进程的每个页面在内存中存放的位置，操作系统要为每个进程建立一张页表。注:页表通常存在PCB(进程控制块)中
        1. 一个进程对应一张页表
        2. 进程的每个页面对应一个页表项
        3. 每个页表项由“页号”和“块号”组成
        4. 页表记录进程页面和实际存放的内存块之间的映射关系 
        5. 每个页表项的长度是相同的
        假设某系统物理内存大小为 4GB，页面大小为 4KB，则 每个页表项至少应该为多少字节?
            内存块大小=页面大小=4KB= 2的12次方B
            4GB的内存总共会被分为 2的32次方 / 2的12次方 = 2的20次方 个内存块内存
            内存块号的范围应该是 0 ~ 2的20次方 -1 
            内存块号至少要用 20 bit 来表示 
            至少要用3B来表示块号(3*8=24bit)
                计算机中内存块的数量-->页表项中块号至少占多少字节
            页表项连续存放，因此页号可以是隐含的，不占存储空间(类比数组)
            由于页号是隐含的，因此每个页表项占3B，存储整个页表至少需要 3*(n+1)B
 

