1. 进程的概念
    程序的一次执行过程，同一个程序多次执行会对应多个进程
    进程的组成：
        PCB(Process Control Block)中，即进程控制块
            记录PID、进程所属用户ID(UID)
            给进程分配了哪些资源
            进程的运行情况
            管理时所需要的信息
            PCB是进程存在的唯 一标志，当进程被创 建时，操作系统为其 创建PCB，当进程结 束时，会回收其PCB
        程序段、数据段
    进程的异步性：各进程按各自独立的，不可预知的速度向前推进，os需要提供“进程同步机制”来解决异步问题

    进程的三种基本状态：
                cpu       其他资源
        运行、   满足         满足
        就绪、   缺           满足   
        阻塞     缺           缺

    进程的组织
        链接方式
            运行队列 多核CPU可有多个进程 同时处于运行态
            就绪队列 通常会把优先级高的进程放在队头
            阻塞队列 很多操作系统还会根据阻塞原因不同，再分为多个阻塞队列 （等待事件A的等待队列，等待事件B的等待队列）
        索引方式
            就绪索引表
            阻塞索引表

    进程控制：实现进程状态转换
        用原语实现
        引起进程切换的事件
            当前进程时间片到
            有更高优先级的进程到达
            当前进程主动阻塞
            当前进程终止
        保存进程运行环境、修改PCB内容和相应队列

    进程的创建
        用户登录    分时系统中用户登录成功，系统会建立一个新的进程
        作业调度    多到系统中，有新的作业放入内存时，会建立一个新的进程
        提供服务    用户向os提出某些请求时，会建立一个进程处理该请求
        应用请求    由用户进程主动请求创建一个子进程

    程序的运行
        CPU中会设置很多 “寄存器”，用来存    放程序运行过程中所 需的某些数据。
        执行完进程的某个指令后后， 另一个进程开始上CPU 运行，在运行过程中也会使用各个寄存器
        在进程切换时先在PCB中保存这个进程的运行环境(保存一些必要的寄存器信息)
        当原来的进程再次投入运行时，可以通过PCB恢复它的运行环境

2. 进程通信（IPC）
    共享存储
        为避免出错，各个进程对共享空间的访问应该是互斥的
        各个进程可使用操作系统内核提供的同步互斥工具(如P、V操作)
    消息传递
    管道通信
        管道只能采用半双工通信，某一时间段内只能实现单向的传输。
        各进程要互斥地访问管道(由操作系统实现)
        当管道写满时，写进程将阻塞，直到读进程将管道中的数据取走，即可唤醒写进程
        当管道读空时，读进程将阻塞，直到写进程往管道中写入数据，即可唤醒读进程。
        管道中的数据一旦被读出，就彻底消失。因此，当多个进程读同一个管道时，可能会错乱。对此，通常有两种解决方案
            允许多个写进程，一个读进程
            允许有多个写进程，多个读进程，但系统会让各个读进程轮流从管道中读数据(Linux 的方案)
        写进程往管道写数据，即便管道没被写满，只要管道没空，读进程就可以从管道读数据
        读进程从管道读数据，即便管道没被读空，只要管道没满，写进程就可以往管道写数据
 
3. 线程概念 多线程模型
    有的进程可能需要“同时”做很多事，而传统的进程只能串行地执行一系列程序。为此，引入了“线程”，来增加并发度。
    线程是一个基本的CPU执行单元， 也是程序执行流的最小单位
    引入线程后，进程只作为除CPU之外的系统资源的分配单元(如打 印机、内存地址空间等都是分配 给进程的)。 
    线程则作为处理机的分配单元。
    线程也有 就绪、阻塞、运行 三种状态
    线程几乎不拥有系统资源，同一进程内的线程共享进程资源
    由于共享内存地址空间，同一进程内的线程间通信无需系统干预
    同进程内的线程切换，系统开销小

4. 线程的实现方式 多线程模型
    线程的实现方式
        用户级线程
            用户级线程由应用程序通过线程库实现， 所有的线程管理工作都由应用程序负责(包括线程切换)
            用户级线程中，线程切换可以在用户态下即可完成，无需操作系统干预。
            在用户看来，是有多个线程。但是在操作系统内核看来，并意识不到线程的存在，用户级线程”就是“从用户视角看能看到的线程”

            优点：用户级线程的切换在用户空间即可完成，不需要切换到核心态，线程管理的系统开销小，效率高
            缺点：当一个用户级线程被阻塞后，整个进程都会被阻塞，并发度不高。多个线程不可在多核处理机上并行运行
            
        内核级线程
            大多数现代操作系统都实现了内核级线程，如 Windows、Linux
            内核级线程的管理工作由操作系统内核完成。
            线程调度、切换等工作都由内核负责，因此内核级线程的切换必然需要在核心态下才能完成。
            操作系统会为每个内核级线程建立相应的 TCB(Thread Control Block，线程控制块)， 通过TCB对线程进行管理。
            “内核级线程”就 是“从操作系统内核视角看能看到的线程”

            优点:当一个线程被阻塞后，别的线程还可 以继续执行，并发能力强。多线程可在多核 处理机上并行执行。 
            缺点:一个用户进程会占用多个内核级线程， 线程切换由操作系统内核完成，需要切换到 核心态，因此线程管理的成本高，开销大。

    多线程模型：在支持内核级线程的系统中，根据用户级线程和内核级线程的映射关系，可以划分为几种多线程模型
        操作系统只“看得见”内核级线程，因此只有内核级线程才是处理机分配的单位。
        一对一模型
            一个用户级线程映射到一个内核级线程。每个用户进程有与用户级线程同数量的内核级线程。
            优点:当一个线程被阻塞后，别的线程还可以继续执行，并发能力强。多线程可在多核处理机上并行执行。
            缺点:一个用户进程会占用多个内核级线程， 系统 线程切换由操作系统内核完成，需要切换到核心态，因此线程管理的成本高，开销大。
        多对一模型
            多个用户级线程映射到一个内核级线程。且一个进程只被分配一个内核级线程。
            优点:用户级线程的切换在用户空间即可完成，不需要切换到核心态，线程管理的系统开销小，效率高
            缺点:当一个用户级线程被阻塞后，整个进程都会被阻塞，并发度不高。多个线程不可在多核处理机上并行运行
        多对多模型
            n 用户及线程映射到 m 个内核级 线程(n >= m)。每个用户进程对应 m 个内核 级线程。
            克服了多对一模型并发度不高的缺点(一个阻塞全体阻塞)，又克服了一对一模型中一个用户进程占用太多内核级线程，开销太大的缺点。
     
      进程表 位于内核空间，
      用户级线程中，线程表位于用户空间进程中，记录了当前进程的线程
      内核级线程中，线程表位于内核空间，记录了所有线程，在固定的表格空间或堆栈空间中，内核级线程数量有限
5. 调度的概念、层次
    基本概念：当有一堆任务要处理，但由于资源有限，这些事情没法同时处理。这就需要确定某种规则来决定处理这些任务的顺序，这就是“调度”研究的问题。
    三个层次
        高级调度（作业调度）: 好几个程序需要启动，到底先启动哪个
        中级调度（内存调度）: 按照某种策略决定将哪个处于挂起状态的进程重新调入内存
        低级调度（进程调度）: 按照某种策略从就绪队列中选取一个进程，将处理机分配给它
    
    进程的挂起状态
        内存不够时，可将某些进程的数据调出外存。等内存空闲或者进程需要运行时再重新调入内存。 
        暂时调到外存等待的进程状态为挂起状态。被挂起的进程PCB会被组织成挂起队列

    七状态模型
        暂时调到外存等待的进程状态为挂起状态(挂起态，suspend)
        挂起态又可以进一步细分为就绪挂起、阻塞挂起两种状态
    
    调度算法：
        先来先服务(FCFS)、短作业优先(SJF)、高响应比优先(HRRN)
        时间片轮转(RR)、优先级、多级反馈队列

6. 进程同步与进程互斥（信号量机制）
    进程同步：解决进程异步问题
    进程互斥
        进程的“并发”需要“共享”的支持。
        各个并发执行的进程不可避免的需要共享一些系统资源(比如内存，又比如打印机、摄像头这样的I/O设备)
        两种资源共享方式：
            互斥共享：一个时间段内只允许一个进程访问该资源（这种资源称为临界资源
                比如：摄像头、打印机，此外还有许多变量、数据、内存缓冲区等）
            同时共享：允许一个时间段内由多个进程“同时”对它们进行访问
        进程互斥指当一个进程访问某临界资源时，另一个想要访问该临界资源的进程必须等待。
        当前访问临界资源的进程访问结束，释放该资源之后，另一个进程才能去访问临界资源。
        管程：Java中类似于管程的机制，如果用关键字 synchronized 来描述一个函数，那么这个函数同一时间段内只能被一个线程调用
        

        
